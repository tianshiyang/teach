<!DOCTYPE html>
<html>
  <head>
    <title>es5继承</title>
  </head>
  <body>
    <!-- <h1>继承</h1> -->
  </body>
  <script>
    // // 1. call方式实现继承
    // // 优点：实现继承属性，但值都不相同
    // // 缺点：无法继承父级类别中原型上的方法
    // function Person(name, age) {
    //   this.name = name
    //   this.age = age
    // }
    // Person.prototype.say = () => {
    //   console.log(this + "sayHi")
    // }
    // function Student(name, age, education) {
    //   Person.call(this, name, age)
    //   this.education = education
    // }
    // Student.prototype = new Person()
    // Student.prototype.play = () => {
    //   console.log("student Play")
    // }
    // let stu = new Student("张三", 20, "本科")
    // console.log(stu.__proto__) // person (Student.prototype = new Person();改变了Student的原型)
    // console.log(stu.play()) // student Play
    

    // prototype 实现继承
    // 优点：继承了父级原型上的方法
    // 缺点：实例化多个Student 都必须共用相同的name 和 age 
    // function Person(name, age) {
    //   this.name = name
    //   this.age = age
    // }
    // Person.prototype.say = () => {
    //   console.log("person say")
    // }
    // function Student(education) {
    //   this.education = education
    // }
    // Student.prototype = new Person("张三", 20)
    // Student.prototype.constructor = Student // 改变原型 构造函数指向
    // let stu = new Student("本科")
    // console.log(stu.name, stu.education) // 张三 本科
    // stu.say() // person say
    // console.log(stu.__proto__.constructor === Student) // true


    // 组合继承
    // 具有call 和 prototype两个的优点
    function Person(name, age) {
      this.name = name
      this.age = age
    }
    Person.prototype.say = () => {
      console.log("person say")
    }
    function Student(education, name, age) {
      Person.call(this, name, age)
      this.education = education
    }
    Student.prototype = new Person()
    Student.prototype.play = () => {
      console.log("student play")
    }
    let stu = new Student("123", "zhangsan", 20)
    stu.say()
    stu.play()
  </script>
</html>